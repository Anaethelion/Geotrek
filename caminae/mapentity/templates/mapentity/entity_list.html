{% extends "mapentity/base.html" %}
{% load i18n leaflet_tags field_verbose_name %}

{% block nav-list %}active{% endblock nav-list %}

{% block extrahead %}
    {{ block.super }}
    {% include "dataTables_template.html" %}
{% endblock extrahead %}

{% block mainmap %}
    {% leaflet_map "mainmap" %}
{% endblock mainmap %}

{% block mainlist %}
    <form id="mainfilter" action="{{ datatables_ajax_url }}" class="well form-inline">
        {{ filterform.form.as_p }}
        <input id="reset" type="reset" class="btn" />
        <a id="filter" class="btn btn-primary"><i class="icon-search icon-white"></i> {% trans "Filter" %}</a>
    </form>

    <table id="objects-list" class="table table-striped table-bordered">
        <thead>
            <tr>
                {% for field in columns %}
                <th>{{ model|verbose:field }}</th>
                {% endfor %}
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
{% endblock mainlist %}


{% block extrabody %}
    {{ block.super }}

    <script type="text/javascript">
        function saveFullContext(map, datatable) {
            localStorage.setItem('list-map-view', 
                                 map.getCenter().lat + ',' + map.getCenter().lng + ',' + map.getZoom());
            localStorage.setItem('list-filter', $('#mainfilter').serialize());
            var sortcol = datatable.fnSettings().aaSorting;
            localStorage.setItem('list-sortcolumns', JSON.stringify(sortcol));
            // layers shown by name
            var layers = [];
            $('form.leaflet-control-layers-list input:checked').each(function () {
                layers.push($(this).parent().text());
            });
            localStorage.setItem('list-layers', JSON.stringify(layers));
        };
        
        function restoreFullContext(map, datatable) {
            var mapView = localStorage.getItem('list-map-view');
            if (mapView) {
                mapView = mapView.split(',');
                map.setView(L.latLng(mapView[0], mapView[1]), mapView[2]);
            }
            var filter = localStorage.getItem('list-filter');
            if (filter) {
                $('#mainfilter').deserialize(filter);
            }
            var sortcol = localStorage.getItem('list-sortcolumns');
            if (sortcol) {
                datatable.fnSort(JSON.parse(sortcol));
            }
            // Show layers by their name
            var layers = localStorage.getItem('list-layers');
            if (layers) {
                layers = JSON.parse(layers);
                $('form.leaflet-control-layers-list input').each(function () {
                    $(this).removeAttr('checked');
                });
                for(var i=0; i<layers.length; i++) {
                    var layer = layers[i];
                    $('form.leaflet-control-layers-list input').each(function () {
                        if ($(this).parent().text() == layer) {
                            $(this).attr('checked', 'checked');
                        }
                    });
                }
                map.layerscontrol._onInputClick();
            }
        };

        function mainmapInit(mainmap, bounds) {
            mainmap.removeControl(mainmap.attributionControl);
            mainmap.doubleClickZoom.disable();
            
            {% if DEBUG %}
            mainmap.on('viewreset moveend', function () {
                var n = objectsLayer.search(mainmap.getBounds()).length;
                objectsLayer.fire('info', {info : n + ' objects shown'});
            });
            mainmap.addControl(new L.Control.Information());
            {% endif %}
            
            var getUrl = function (properties, layer) {
                //TODO use nice JS url rewriting
                return "{{ model.get_generic_detail_url }}".replace('0', properties.pk);
            };
            
            var objectsLayer = new MapEntity.ObjectsLayer(null, {
                objectUrl: getUrl
            });
            
            mainmap.addLayer(objectsLayer);
            objectsLayer.load("{{ model.get_layer_url }}");

            // init ajax list
            var dt = initAjaxList(mainmap, objectsLayer);

            restoreFullContext(mainmap, dt);
            $(window).unload(function () {
                saveFullContext(mainmap, dt);
            });
            
            $('#filter').click();
        }

        /* Table initialisation */
        function initAjaxList(map, objectsLayer) {

            var filterform = $('#mainfilter')
              , submitbutton = $('#filter')
              , resetbutton = $('#reset')
              , ajax_list = $('#objects-list')
              , results_panel = document.getElementById('results-panel')
            ;

            // initialize data table
            var dt = JQDataTable.init(
                  ajax_list
                , null // no load at startup
                , {
                    // Hide pk
                    "aoColumnDefs": [ { "bVisible": false, "aTargets": [ 0 ] } ],
                    "fnCreatedRow": function( nRow, aData, iDataIndex ) {
                        $(nRow).hover(function(){
                            objectsLayer.highlight(aData[0]);
                        },
                        function(){
                            objectsLayer.highlight(aData[0], false);
                        });
                    },
                    "sDom": "<'row-fluid'<'span6'i><'span6'f>r>t<'row-fluid'<'span6'l><'span6'p>>",
                    aaData: [],
                    iDeferLoading: 0
                }
            );

            objectsLayer.on('click', function(e) {
                var search_pk = e.layer.properties.pk;

                // This may also be used
                // dt.fnGetPosition(dt.$('tr').find('td:first-child a[data-pk=19]').closest('tr').get(0))

                var dt_settings = dt.fnSettings();
                var pagingInfo = dt_settings.oInstance.fnPagingInfo()
                var aiRows = dt_settings.aiDisplay;
                var pk_column = 0;
                for (var position = 0, c = aiRows.length; position < c; position++) {
                    var iRow = aiRows[position];
                    var aData = dt.fnGetData(iRow);
                    if(aData[pk_column] === search_pk) {
                        var page_idx = Math.floor(position / pagingInfo.iLength);
                        if (page_idx != pagingInfo.iTabIndex) {
                            dt_settings._iDisplayStart =  page_idx * pagingInfo.iLength;

                            // There is currently no api to unregister cleanly a callback (but it's just an array...)
                            var first = true;
                            dt_settings.oApi._fnCallbackReg(dt_settings, 'aoDrawCallback',
                                function(oSettings) {
                                    if(first) {
                                        first = false;
                                        // once the page is loaded make the matched record blink
                                        $(dt.fnGetNodes(iRow)).hide().show('slow').hide('fast').show('slow');
                                    }
                                },
                                'objectLayerClick_' + new Date().getTime() // ~random unique name
                            );

                            dt.oApi._fnCalculateEnd(dt_settings);
                            dt.oApi._fnDraw(dt_settings);
                        }

                        break;
                    }
                }
            });



            // Hardcore customizations
            $('li.next a').html($('li.next a').html().replace('Next', ''));
            $('li.prev a').html($('li.prev a').html().replace('Previous', ''));

            // on JSON load, return the json used by dataTable
            // Update also the map given the layer's pk
            var extract_data_and_pks = function(data, type, callback_args) {
                callback_args.map_obj_pk = data.map_obj_pk;
                return data.aaData;
            }

            function ajaxTrigger(cb) {
                var spinner = new Spinner().spin(results_panel);

                var url = filterform.attr("action") + '?' + filterform.serialize()

                dt.fnReloadAjax(url, extract_data_and_pks, function() {
                    spinner.stop();
                    // Show and save number of results
                    MapEntity.showNumberSearchResults(dt.fnSettings().fnRecordsTotal());
                    cb.apply(cb, arguments);
                });

                return false;
            }

            // Store the map bounds as WKT in the bbox field
            function storeBoundsToField($field, bounds) {
                var rect = new L.Rectangle([bounds._northEast, bounds._southWest]);
                $field.val(MapEntity.getWKT(rect));
            }

            var initial_map_bounds = map.getBounds();
            var bbox_field = $('#id_bbox');
            var storeCurrentMapBoundsToField = function() { storeBoundsToField(bbox_field, map.getBounds()); };

            // Restore initial map bounds on trigger
            submitbutton.click(ajaxMapObjectsUpdateOnly);
            resetbutton.click(function() {
                MapEntity.resetForm(filterform);
                mapBoundsUpdateNoListen(initial_map_bounds, listenMapBoundsUpdate);
                ajaxMapObjectsUpdateOnly();
                return false;
            });

            // Updates map bounds if necessary (return a boolean if bounds were updated)
            // Unregistering specific callback to avoid triggering ajax request
            function mapBoundsUpdateNoListen(new_bounds, cb) {
                // no need to update if bounds are equals
                if (map.getBounds().equals(new_bounds))
                    return false;

                // deactivate/reactivate listener to trigger our own callback
                cb(false);
                map.fitBounds(new_bounds);
                cb(true);
                return true;
            }

            function ajaxMapObjectsUpdateOnly() {
                storeCurrentMapBoundsToField();
                ajaxTrigger(function(oSettings, callback_args) {
                    objectsLayer.updateFromPks(callback_args.map_obj_pk);
                });
            }

            function ajaxMapBoundsUpdateOnly() {
                storeCurrentMapBoundsToField();
                ajaxTrigger(function(){});
            };

            function listenMapBoundsUpdate(on) {
                on = on === undefined ? true: on;
                map[on ? 'on': 'off']('moveend', ajaxMapBoundsUpdateOnly);
            }

            listenMapBoundsUpdate(true);
            
            return dt;
        };
    </script>

{% endblock extrabody %}
